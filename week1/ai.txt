Prompt:
Why is my if-statement not working? I'm running a bash script with set -euxo pipefail. When it gets to the if-statement if [[ $line =~ $line_pattern ]] ; then sum=$sum+${line%%(^[0..9]+ )}; echo ${line%%(^[0..9]+ )} ; fi it prints + [[ 19 636 =~ ^[0..9]+ [0..9]+ ]] but then doesn't execute the associated then-statement. Why is it not working?
ChatGPT Response:
The issue lies in your use of [0..9] inside the regular expression. That is not valid syntax for a character class in Bash regex.

ğŸ” Breakdown of the Problem
Your code:
if [[ $line =~ $line_pattern ]]; then
    sum=$sum+${line%%(^[0..9]+ )};
    echo ${line%%(^[0..9]+ )};
fi

Output:
+ [[ 19 636 =~ ^[0..9]+ [0..9]+ ]]

Why it's not working:

[[ ... =~ ... ]] in Bash uses extended regular expressions (ERE).

In ERE, a character class for digits is written as [0-9], not [0..9].

[0..9] is interpreted literally, as the characters 0, ., . and 9, which do not match digits in the way you expect.

So the regex does not match the line, and the then clause does not run.

âœ… Fix

Update your pattern to use a valid regex:

line_pattern='^[0-9]+ [0-9]+'


Make sure it's quoted, and use [0-9] instead of [0..9].

Fixed version of your if-statement:
line_pattern='^[0-9]+ [0-9]+'

if [[ $line =~ $line_pattern ]]; then
    sum=$((sum + ${line%% *}))  # extract the first number and add it to sum
    echo "${line%% *}"          # print the first number
fi


Also, for arithmetic, use $((...)) instead of sum=$sum+.... That was also incorrect syntax in Bash.

ğŸ’¡ What does ${line%% *} do?

${line%% *} removes everything after the first space (and the space itself).

So if line="19 636", ${line%% *} returns 19.

âœ… Final Working Snippet
#!/bin/bash
set -euxo pipefail

sum=0
line="19 636"
line_pattern='^[0-9]+ [0-9]+'

if [[ $line =~ $line_pattern ]]; then
    value=${line%% *}
    sum=$((sum + value))
    echo "$value"
fi

echo "Sum is $sum"


This will print:

+ [[ 19 636 =~ ^[0-9]+ [0-9]+ ]]
+ value=19
+ sum=19
+ echo 19
19
+ echo Sum is 19
Sum is 19


Let me know if your actual input format is more complex.


Prompt:
That fixed the problem, but what if I want the second number to be added to sum instead of the first

ChatGPT Response:
Great â€” glad that fixed it!

If you want to extract the second number from a line like:

19 636


â€¦and add 636 to sum, there are a few clean ways to do it.

âœ… Option 1: Use awk (easy and reliable)
if [[ $line =~ $line_pattern ]]; then
    value=$(awk '{print $2}' <<< "$line")
    sum=$((sum + value))
    echo "$value"
fi


This prints the second field in the line using whitespace as the delimiter.

âœ… Option 2: Use Bash string manipulation

If you'd rather avoid subprocesses like awk, you can split the string using read:

if [[ $line =~ $line_pattern ]]; then
    read -r first second <<< "$line"
    sum=$((sum + second))
    echo "$second"
fi


This assigns first=19, second=636.

read is very efficient and idiomatic in Bash.

âœ… Option 3: Use cut

Another external tool approach:

value=$(cut -d' ' -f2 <<< "$line")
sum=$((sum + value))
echo "$value"

Final Sample Script
#!/bin/bash
set -euxo pipefail

sum=0
line="19 636"
line_pattern='^[0-9]+ [0-9]+'

if [[ $line =~ $line_pattern ]]; then
    read -r first second <<< "$line"
    sum=$((sum + second))
    echo "$second"
fi

echo "Sum is $sum"


Output:

+ [[ 19 636 =~ ^[0-9]+ [0-9]+ ]]
+ read -r first second
+ sum=636
+ echo 636
636
+ echo Sum is 636
Sum is 636


Let me know if the line has more complex formatting or multiple spaces â€” I can adjust accordingly.
